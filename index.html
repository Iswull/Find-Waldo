<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Let‘s Waldo</title>

  <script src="https://unpkg.com/jspsych@latest"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@latest"></script>
  <script src="https://unpkg.com/@jspsych/plugin-preload@latest"></script>
  <script src="https://unpkg.com/@jspsych/plugin-call-function@latest"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-html-form@latest"></script>
  <link href="https://unpkg.com/jspsych@latest/css/jspsych.css" rel="stylesheet" />

  <style>
    body { background:#111; color:#eee; margin:0; }
    .wrap { max-width: 900px; margin: 48px auto; padding: 0 18px; line-height: 1.75; }
    .muted { opacity: 0.82; font-size: 14px; }
    .key { display:inline-block; padding:2px 8px; border:1px solid rgba(255,255,255,0.25); border-radius:8px; }
    code { background: rgba(255,255,255,0.10); padding: 2px 6px; border-radius: 6px; }
  </style>
</head>

<body></body>

<script>


// When running on GitHub Pages, serve images from the same origin to avoid CORS/caching issues.
// Put all .png files in the same folder as this HTML (repo root).
const BASE = "./";
const WALDO_REF = BASE + "Waldo.png";

const STIM = [
  { id: 1,  present: BASE + "Waldo_1_present.png",  absent: BASE + "Waldo_1_absent.png" },
  { id: 2,  present: BASE + "Waldo_2_present.png",  absent: BASE + "Waldo_2_absent.png" },
  { id: 3,  present: BASE + "Waldo_3_present.png",  absent: BASE + "Waldo_3_absent.png" },
  { id: 4,  present: BASE + "Waldo_4_present.png",  absent: BASE + "Waldo_4_absent.png" },
  { id: 5,  present: BASE + "Waldo_5_present.png",  absent: BASE + "Waldo_5_absent.png" },
  { id: 6,  present: BASE + "Waldo_6_present.png",  absent: BASE + "Waldo_6_absent.png" },
  { id: 7,  present: BASE + "Waldo_7_present.png",  absent: BASE + "Waldo_7_absent.png" },
  { id: 8,  present: BASE + "Waldo_8_present.png",  absent: BASE + "Waldo_8_absent.png" },
  { id: 9,  present: BASE + "Waldo_9_present.png",  absent: BASE + "Waldo_9_absent.png" },
  { id: 10, present: BASE + "Waldo_10_present.png", absent: BASE + "Waldo_10_absent.png" },
  { id: 11, present: BASE + "Waldo_11_present.png", absent: BASE + "Waldo_11_absent.png" },
  { id: 12, present: BASE + "Waldo_12_present.png", absent: BASE + "Waldo_12_absent.png" }
];

const PRACTICE_STIM = {
  present: BASE + "Waldo_prac_present.png",
  absent:  BASE + "Waldo_prac_absent.png"
};

const CONDITIONS = ["FULL", "RSVP", "UNCUED", "CUED"];

const ORDER_BY_GROUP = {
  A: ['FULL','RSVP','UNCUED','CUED'],
  B: ['RSVP','UNCUED','CUED','FULL'],
  C: ['UNCUED','CUED','FULL','RSVP'],
  D: ['CUED','FULL','RSVP','UNCUED'],
};


const PARAM = {
  preFix: 0,  // 不在每个 trial 开头额外呈现中心注视点
  seg: 150,    // RSVP/UNCUED/CUED 条件切块呈现时长
  mask: 150,
  cue: 250,      // 只有 CUED 用
  fullDur: 2400, // FULL 条件整图呈现时长

  // 反应限制
  respLimit: 2500,
  keyPresent: "f",
  keyAbsent: "j",

  // 试次间隔
  iti: 500,

  // 切块网格
  rows: 4,
  cols: 4,
  segSizePx: 260, // (legacy) 会在运行时同步为 cellSize，使 stage 为 1:1 且均匀 4×4

  // 简化：每个条件 12P+12A（=24 trials/cond）
  nPresentPerCond: 12,
  nAbsentPerCond: 12
};

// 初始化 jsPsych
const jsPsych = initJsPsych({
on_finish: function(){
    jsPsych.data.get().localSave('csv', 'waldo_exp5_4cond_step1.csv');
}
});

// 基本信息采集
const demographics = {
  type: jsPsychSurveyHtmlForm,
  html: `
    <div class="wrap">
      <h2>基本信息</h2>

      <p>
        <label>年龄（岁）：
          <input name="age" type="number" min="10" max="99" required style="width:120px; margin-left:8px;" />
        </label>
      </p>

      <p>
        <label>性别：
          <select name="gender" required style="width:160px; margin-left:8px;">
            <option value="" selected disabled>请选择</option>
            <option value="female">女</option>
            <option value="male">男</option>
            <option value="other">其他/不便透露</option>
          </select>
        </label>
      </p>

      <p>
        <label>组别（由主试分配）：
          <select name="group" required style="width:160px; margin-left:8px;">
            <option value="" selected disabled>请选择</option>
            <option value="A">A</option>
            <option value="B">B</option>
            <option value="C">C</option>
            <option value="D">D</option>
          </select>
        </label>
      </p>

      <p class="muted">填写完成后点击“继续”。</p>
    </div>
  `,
  button_label: "继续",
  on_finish: function(data){
    const r = data.response || {};
    const ageNum = r.age === "" || r.age == null ? null : Number(r.age);
    jsPsych.data.addProperties({
      age: Number.isFinite(ageNum) ? ageNum : null,
      gender: r.gender || null,
      group: r.group || null
    });
  }
};

// 全局字段：任务名 + 一个随机被试ID
jsPsych.data.addProperties({
  task: "waldo_exp5_4cond_replication",
  subject_id: "S" + String(Math.floor(Math.random()*1e9))

});

const preload = {
  type: jsPsychPreload,
  images: [
    ...STIM.flatMap(s => [s.present, s.absent]),
    PRACTICE_STIM.present,
    PRACTICE_STIM.absent,
    WALDO_REF
  ],
  message: `
    <div class="wrap">
      <p>正在加载实验图片，请稍候……</p>
      <p class="muted">
        图片较多，加载时间可能需要几十秒。
        <br>请保持网络连接，不要刷新页面。
      </p>
    </div>
  `
};

const instructions_page1 = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: `
  <div class="wrap">
    <h2>Waldo 视觉搜索任务</h2>
    <p>欢迎参加实验。你将看到一系列场景图片（有时会以<strong>16个小方块</strong>的方式快速呈现）。你的任务始终相同：</p>
    <p><b>判断该场景中是否出现 Waldo。</b></p>

    <h3 style="margin-top:18px;">按键作答</h3>
    <p>请尽量又快又准地作答：</p>
    <p><span class="key">F</span> = 有 Waldo　　<span class="key">J</span> = 没有 Waldo</p>

    <h3 style="margin-top:18px;">作答时间限制</h3>
    <p>每道题作答时间有限，看到问题后请尽快按键，避免超时。</p>

    <h3 style="margin-top:18px;">实验流程</h3>
    <p>实验包含 <b>4 个呈现条件</b>。每个条件开始前会先做 <b>2 道练习</b>，每题都会给出反馈。</p>
    <p>练习后进入该条件的正式题目：共 <b>24 题</b>。正式阶段<strong>不再提供反馈</strong>。</p>
    <p>全部完成后实验自动结束并保存数据。</p>

    <h3 style="margin-top:18px;">注意事项</h3>

    <p>请保持注意力专注，尽量不要分心或离开屏幕。</p>
    <p>实验过程中不要切换窗口或刷新页面。</p>
    <p>请提前将手指放在 F 和 J 键上。</p>

    <p class="muted">按 <b>空格键</b> 进入下一页查看 Waldo 示例。</p>
  </div>
`,
  choices: [" "],
  record_data: false
};

const instructions_page2 = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: `
  <div class="wrap">
    <h2>Waldo 示例</h2>
    <p class="muted">下面是 Waldo 的参考图。请记住他的典型特征，以便在场景中快速识别。</p>

    <div style="margin:16px 0; display:flex; gap:18px; align-items:center; flex-wrap:wrap;">
      <img src="${WALDO_REF}" alt="Waldo reference" style="width:180px; height:180px; object-fit:contain; border-radius:12px; border:1px solid rgba(255,255,255,0.18); background:rgba(255,255,255,0.04); padding:10px;" />
      <div style="min-width:240px;">
        <p style="margin:0 0 8px 0;"><b>识别要点</b></p>
        <p>红白条纹上衣</p>
        <p>蓝色长裤</p>
        <p>红白帽子</p>
        <p>圆框眼镜</p>
        <p class="muted" style="margin:10px 0 0 0;">提示：每题作答时间有限，请集中注意力、及时作答。</p>
      </div>
    </div>

    <p class="muted">准备好后按 <b>空格键</b> 开始实验。</p>
  </div>
`,
  choices: [" "],
  record_data: false
};

let CURRENT_TRIAL = { stim_id: null, img_path: null, target_present: null };

// 兼容不同 jsPsych 版本：正确“取出” timeline_variables 里的真实值
function TV(name){
  // jsPsych v8: evaluateTimelineVariable
  if (typeof jsPsych.evaluateTimelineVariable === 'function') {
    return jsPsych.evaluateTimelineVariable(name);
  }
  // jsPsych v7: timelineVariable(name, evaluateFunctions)
  if (typeof jsPsych.timelineVariable === 'function') {
    try {
      return jsPsych.timelineVariable(name, true);
    } catch (e) {
      return jsPsych.timelineVariable(name);
    }
  }
  return undefined;
}

// cued fixation 
const fixation = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: ``,
  choices: "NO_KEYS",
  trial_duration: 0,
  record_data: false,

  on_start: function(){
    CURRENT_TRIAL.stim_id = TV('stim_id');
    CURRENT_TRIAL.img_path = TV('img_path');
    CURRENT_TRIAL.target_present = TV('target_present');
  }
};

// 把每个 trial 变成：
// fixation(300ms) -> cued_present(16段) -> decide(F/J)
// CUED 的 16 段时序（每段）：
// 1) 切块呈现 seg=150ms
// 2) 彩色 mask mask=150ms
// 3) 下一位置注视点 cue=250ms（最后一段后不呈现）

// 1.生成 4×4 的“蛇形路径”位置（用网格坐标 r/c，而不是屏幕百分比）
function makeSnakePositions(){
  const pos = [];
  for(let r=0; r<PARAM.rows; r++){
    if(r % 2 === 0){
      for(let c=0; c<PARAM.cols; c++) pos.push({ r, c });
    } else {
      for(let c=PARAM.cols-1; c>=0; c--) pos.push({ r, c });
    }
  }
  return pos; // 共 rows*cols 个位置
}
const SNAKE_POS = makeSnakePositions();

// 2.等待（ms）
function waitMs(ms){ return new Promise(res => setTimeout(res, ms)); }

// 计算“正方形 stage”与每个网格 cell 的几何信息
let STAGE_INFO = null;
function computeStageInfo(){
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const side = Math.min(vw, vh);

  // 让每格为整数像素，避免缝隙
  const cell = Math.floor(side / PARAM.cols);
  const size = cell * PARAM.cols;

  const left = Math.floor((vw - size) / 2);
  const top  = Math.floor((vh - size) / 2);

  return { left, top, size, cell };
}

// 3.在 jsPsych 显示区域里创建一个 stage
function ensureStage(){
  const display = jsPsych.getDisplayElement() || document.body;
  let s = display.querySelector('#stage');
  if(!s){
    s = document.createElement('div');
    s.id = 'stage';
    display.appendChild(s);
  }

  // 每次进入呈现阶段都重新计算（支持不同屏幕/全屏变化）
  STAGE_INFO = computeStageInfo();

  s.style.position = 'absolute';
  s.style.left = STAGE_INFO.left + 'px';
  s.style.top  = STAGE_INFO.top  + 'px';
  s.style.width  = STAGE_INFO.size + 'px';
  s.style.height = STAGE_INFO.size + 'px';
  s.style.overflow = 'hidden';
  s.style.background = 'transparent';

  // 调试时可打开边框
  // s.style.border = '1px solid rgba(255,255,255,0.25)';

  s.innerHTML = '';
  return s;
}

// 4.加载图片（把相对路径解析成 http://localhost... 的绝对 URL）
function resolveUrl(path){
  return new URL(path, window.location.href).href;
}

function normalizeImgPath(maybePath, targetPresent){
  if(typeof maybePath === 'string') return maybePath;
  if(maybePath && typeof maybePath === 'object'){
    // 常见误传：把 STIM 对象直接塞进 img_path
    if('present' in maybePath || 'absent' in maybePath){
      return targetPresent ? maybePath.present : maybePath.absent;
    }
    // 其它可能的包装
    if('path' in maybePath) return maybePath.path;
    if('url' in maybePath) return maybePath.url;
  }
  return String(maybePath);
}
function loadImage(path){
  const url = resolveUrl(path);
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = async () => {
      try { if(img.decode) await img.decode(); } catch(e) {}
      resolve(img);
    };
    img.onerror = () => reject(new Error('图片加载失败(URL): ' + url));
    // Same-origin on GitHub Pages doesn't need CORS; keep anonymous only for cross-origin.
    if(!url.startsWith(window.location.origin)) img.crossOrigin = 'anonymous';
    img.src = url;
  });
}

// 5.计算第 segIndex 块在“原图”上应该裁切的区域
function getCropRect(imgW, imgH, segIndex){
  const r = Math.floor(segIndex / PARAM.cols);
  const c = segIndex % PARAM.cols;
  const sw = imgW / PARAM.cols;
  const sh = imgH / PARAM.rows;
  return { sx: c*sw, sy: r*sh, sw, sh };
}

// 6.在某个位置画出“切块”
function drawSegmentAt(stage, imgEl, segIndex, pos){
  const info = STAGE_INFO || computeStageInfo();
  const size = info.cell; // 

  const cnv = document.createElement('canvas');
  cnv.width = size;
  cnv.height = size;
  cnv.style.position = 'absolute';
  cnv.style.left = (pos.c * size) + 'px';
  cnv.style.top  = (pos.r * size) + 'px';
  stage.appendChild(cnv);

  const ctx = cnv.getContext('2d');
  const rect = getCropRect(imgEl.naturalWidth, imgEl.naturalHeight, segIndex);
  ctx.drawImage(imgEl, rect.sx, rect.sy, rect.sw, rect.sh, 0, 0, cnv.width, cnv.height);
}

// 6.1 在 stage 中心呈现一个切块（给 RSVP 用：所有切块都在中心快速串流）
function drawSegmentCenter(stage, imgEl, segIndex){
  const info = STAGE_INFO || computeStageInfo();
  const size = info.cell;

  const cnv = document.createElement('canvas');
  cnv.width = size;
  cnv.height = size;
  cnv.style.position = 'absolute';
  cnv.style.left = (info.size/2 - size/2) + 'px';
  cnv.style.top  = (info.size/2 - size/2) + 'px';
  stage.appendChild(cnv);

  const ctx = cnv.getContext('2d');
  const rect = getCropRect(imgEl.naturalWidth, imgEl.naturalHeight, segIndex);
  ctx.drawImage(imgEl, rect.sx, rect.sy, rect.sw, rect.sh, 0, 0, cnv.width, cnv.height);
}

// 6.2 在 stage 中心呈现 mask（给 RSVP 用）
function drawMaskCenter(stage){
  const info = STAGE_INFO || computeStageInfo();
  const size = info.cell;

  const cnv = document.createElement('canvas');
  cnv.width = size;
  cnv.height = size;
  cnv.style.position = 'absolute';
  cnv.style.left = (info.size/2 - size/2) + 'px';
  cnv.style.top  = (info.size/2 - size/2) + 'px';
  stage.appendChild(cnv);

  const ctx = cnv.getContext('2d');
  const block = Math.max(10, Math.round(size / 13));
  for(let y=0; y<size; y+=block){
    for(let x=0; x<size; x+=block){
      ctx.fillStyle = `hsl(${Math.random()*360}, 85%, 55%)`;
      ctx.fillRect(x, y, block, block);
    }
  }
}

// 7.在某个网格位置画 mask（彩色马赛克）
function drawMaskAt(stage, pos){
  const info = STAGE_INFO || computeStageInfo();
  const size = info.cell;

  const cnv = document.createElement('canvas');
  cnv.width = size;
  cnv.height = size;
  cnv.style.position = 'absolute';
  cnv.style.left = (pos.c * size) + 'px';
  cnv.style.top  = (pos.r * size) + 'px';
  stage.appendChild(cnv);

  const ctx = cnv.getContext('2d');
  // 让 mask 的块数随 cellSize 缩放，保持“马赛克密度”大致一致
  const block = Math.max(10, Math.round(size / 13));
  for(let y=0; y<size; y+=block){
    for(let x=0; x<size; x+=block){
      ctx.fillStyle = `hsl(${Math.random()*360}, 85%, 55%)`;
      ctx.fillRect(x, y, block, block);
    }
  }
}

// 8.在某个网格位置画 cue '+'（下一个位置提示）
function drawCuePlus(stage, pos){
  const info = STAGE_INFO || computeStageInfo();
  const size = info.cell;

  const d = document.createElement('div');
  d.style.position = 'absolute';
  d.style.left = (pos.c * size + size/2) + 'px';
  d.style.top  = (pos.r * size + size/2) + 'px';
  d.style.transform = 'translate(-50%, -50%)';
  d.style.fontSize = Math.round(size * 0.18) + 'px';
  d.style.color = '#fff';
  d.textContent = '+';
  stage.appendChild(d);
}

// 6.3 呈现 FULL：整图放进 1:1 stage
async function presentFull(imgPath){
  const stage = ensureStage();
  if(STAGE_INFO) PARAM.segSizePx = STAGE_INFO.cell;

  const fixedPath = normalizeImgPath(imgPath, CURRENT_TRIAL.target_present);
  const img = await loadImage(fixedPath);

  stage.innerHTML = '';
  const el = document.createElement('img');
  el.src = resolveUrl(fixedPath);
  el.style.width = '100%';
  el.style.height = '100%';
  el.style.objectFit = 'cover'; 
  el.draggable = false;
  stage.appendChild(el);

  await waitMs(PARAM.fullDur);
  stage.innerHTML = '';
}

// 6.4 呈现 UNCUED：蛇形位置依次呈现 16 段
async function presentUncued16(imgPath){
  const stage = ensureStage();
  if(STAGE_INFO) PARAM.segSizePx = STAGE_INFO.cell;
  stage.innerHTML = '<div style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:18px;opacity:.85;">Loading…</div>';

  const fixedPath = normalizeImgPath(imgPath, CURRENT_TRIAL.target_present);
  const img = await loadImage(fixedPath);

  for(let i=0; i<16; i++){
    stage.innerHTML = '';
    drawSegmentAt(stage, img, i, SNAKE_POS[i]);
    await waitMs(PARAM.seg);
    stage.innerHTML = '';
  }
}

// 6.5 呈现 RSVP：16 段都在 stage 中心串流
async function presentRsvp16(imgPath){
  const stage = ensureStage();
  if(STAGE_INFO) PARAM.segSizePx = STAGE_INFO.cell;
  stage.innerHTML = '<div style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:18px;opacity:.85;">Loading…</div>';

  const fixedPath = normalizeImgPath(imgPath, CURRENT_TRIAL.target_present);
  const img = await loadImage(fixedPath);

  for(let i=0; i<16; i++){
    stage.innerHTML = '';
    drawSegmentCenter(stage, img, i);
    await waitMs(PARAM.seg);
    stage.innerHTML = '';
  }
}

// 9.执行一次 CUED 呈现（16 段循环）
async function presentCued16(imgPath){
  const stage = ensureStage();
  if(STAGE_INFO) PARAM.segSizePx = STAGE_INFO.cell;
  stage.innerHTML = '<div style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:18px;opacity:.85;">Loading…</div>';

  const fixedPath = normalizeImgPath(imgPath, CURRENT_TRIAL.target_present);
  const img = await loadImage(fixedPath);

  for(let i=0; i<16; i++){
    stage.innerHTML = '';
    drawSegmentAt(stage, img, i, SNAKE_POS[i]);
    await waitMs(PARAM.seg);

    stage.innerHTML = '';
    drawMaskAt(stage, SNAKE_POS[i]);
    await waitMs(PARAM.mask);

    stage.innerHTML = '';
    if(i < 15){
      drawCuePlus(stage, SNAKE_POS[i+1]);
      await waitMs(PARAM.cue);
    }
  }

  stage.innerHTML = '';
}

// 10.把“呈现阶段”做成一个 jsPsych trial
const cued_present = {
  type: jsPsychCallFunction,
  async: true,

  func: function(done){
    const run = async () => {
      const imgPath = CURRENT_TRIAL.img_path;
      if(!imgPath){
        throw new Error('imgPath is empty/undefined.');
      }
      await presentCued16(imgPath);
    };

    const p = run();

    // callback-style
    if (typeof done === 'function') {
      p.then(() => done()).catch((e) => { console.error(e); done(); });
    }

    // promise-style
    return p;
  },

  data: {
    stage: 'cued_present',
    seg_ms: PARAM.seg,
    mask_ms: PARAM.mask,
    cue_ms: PARAM.cue,
    rows: PARAM.rows,
    cols: PARAM.cols
  }
};

// 10.5 ITI（空屏）
const iti_blank = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: '',
  choices: 'NO_KEYS',
  trial_duration: PARAM.iti,
  record_data: false
};

// FULL 呈现 trial
const full_present = {
  type: jsPsychCallFunction,
  async: true,
  func: function(done){
    const run = async () => {
      const imgPath = CURRENT_TRIAL.img_path;
      if(!imgPath) throw new Error('imgPath is empty/undefined.');
      await presentFull(imgPath);
    };
    const p = run();
    if (typeof done === 'function') p.then(() => done()).catch((e)=>{console.error(e); done();});
    return p;
  },
  data: { stage: 'full_present', fullDur: PARAM.fullDur, rows: PARAM.rows, cols: PARAM.cols }
};

// RSVP 呈现 trial
const rsvp_present = {
  type: jsPsychCallFunction,
  async: true,
  func: function(done){
    const run = async () => {
      const imgPath = CURRENT_TRIAL.img_path;
      if(!imgPath) throw new Error('imgPath is empty/undefined.');
      await presentRsvp16(imgPath);
    };
    const p = run();
    if (typeof done === 'function') p.then(() => done()).catch((e)=>{console.error(e); done();});
    return p;
  },
  data: { stage: 'rsvp_present', seg_ms: PARAM.seg, rows: PARAM.rows, cols: PARAM.cols }
};

// UNCUED 呈现 trial
const uncued_present = {
  type: jsPsychCallFunction,
  async: true,
  func: function(done){
    const run = async () => {
      const imgPath = CURRENT_TRIAL.img_path;
      if(!imgPath) throw new Error('imgPath is empty/undefined.');
      await presentUncued16(imgPath);
    };
    const p = run();
    if (typeof done === 'function') p.then(() => done()).catch((e)=>{console.error(e); done();});
    return p;
  },
  data: { stage: 'uncued_present', seg_ms: PARAM.seg, rows: PARAM.rows, cols: PARAM.cols }
};

// cued decision
function makeDecideTrial(conditionLabel){
  return {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
      <div class="wrap">
        <p style="font-size:20px;">这个场景里有没有 Waldo？</p>
        <p class="muted">按 <b>F</b> = 有　　按 <b>J</b> = 无</p>
      </div>
    `,
    choices: [PARAM.keyPresent, PARAM.keyAbsent],
    trial_duration: PARAM.respLimit,
    data: {
      condition: conditionLabel,
      stim_id: () => TV('stim_id'),
      img_path: () => TV('img_path'),
      target_present: () => TV('target_present')
    },
    on_finish: function(data){
      const timedOut = (data.response == null);
      data.timed_out = timedOut ? 1 : 0;

      const ans =
        data.response === PARAM.keyPresent ? 1 :
        data.response === PARAM.keyAbsent  ? 0 : null;
      data.answer_present = ans;

      // If timed out, do not score as incorrect; leave missing for accuracy analyses.
      if(timedOut){
        data.correct = null;
      } else {
        data.correct = (ans === data.target_present) ? 1 : 0;
      }
    }
  };
}

const decide_FULL   = makeDecideTrial('FULL');
const decide_RSVP   = makeDecideTrial('RSVP');
const decide_UNCUED = makeDecideTrial('UNCUED');
const decide_CUED   = makeDecideTrial('CUED');

//自动生成 12P + 12A（共 24 个）试次
//每个场景 id=1..12：present 用一次（target_present=1）；absent  用一次（target_present=0）
//把 24 条随机打乱。每个场景在 present/absent 中各出现一次（平衡）。
function buildTrials_12P12A(){
  const trials = [];
  // 12 条 present
  for(const s of STIM){
    trials.push({
      stim_id: s.id,
      img_path: s.present,
      target_present: 1
    });
  }
  // 12 条 absent
  for(const s of STIM){
    trials.push({
      stim_id: s.id,
      img_path: s.absent,
      target_present: 0
    });
  }
  // 随机打乱顺序
  return jsPsych.randomization.shuffle(trials);
}

const base_trials = buildTrials_12P12A();

// Build 2 practice trials (1 present + 1 absent) and shuffle
function buildPracticeTrials_1P1A(){
  const tvs = [
    { stim_id: 'prac', img_path: PRACTICE_STIM.present, target_present: 1 },
    { stim_id: 'prac', img_path: PRACTICE_STIM.absent,  target_present: 0 }
  ];
  return jsPsych.randomization.shuffle(tvs);
}

// Detailed feedback after each practice decision
const practice_feedback = {
  type: jsPsychHtmlKeyboardResponse,
  choices: 'NO_KEYS',
  trial_duration: 900,
  record_data: false,
  stimulus: function(){
    const last = jsPsych.data.get().last(1).values()[0];
    const timedOut = (last.response == null);
    const correct = last.correct === 1;
    const ansTxt = last.target_present === 1 ? '有 Waldo' : '没有 Waldo';

    let title = '';
    let detail = '';
    if(timedOut){
      title = '超时';
      detail = `你没有在规定时间内作答。<br>正确答案：<b>${ansTxt}</b><br><span class="muted">请集中注意力并尽快作答。</span>`;
    } else if(correct){
      title = '正确';
      detail = `<span class="muted">继续保持。</span>`;
    } else {
      title = '错误';
      detail = `正确答案：<b>${ansTxt}</b><br><span class="muted">下一题请更专注并及时作答。</span>`;
    }

    return `
      <div class="wrap" style="text-align:center;">
        <div style="font-size:34px; margin-bottom:10px;">${title}</div>
        <div style="font-size:18px; line-height:1.6;">${detail}</div>
      </div>
    `;
  }
};

function practiceIntro(conditionLabel){
  const desc = {
    FULL:   '整图呈现',
    RSVP:   '中心 RSVP：16 段切块在中心快速串流',
    UNCUED: '蛇形位置呈现：16 段依次出现在各网格位置',
    CUED:   '蛇形位置呈现 + 下一位置提示'
  };
  return {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
      <div class="wrap">
        <h3>练习：${conditionLabel}</h3>
        <p>${desc[conditionLabel]}</p>
        <p>本练习只有 <b>2</b> 题，用于熟悉该条件的呈现方式与按键。</p>
        <p class="muted">请尽量又快又准：<b>F</b>=有，<b>J</b>=无。按空格开始练习。</p>
      </div>
    `,
    choices: [' '],
    record_data: false
  };
}

function makePracticeBlock(conditionLabel){
  const tvs = buildPracticeTrials_1P1A();

  // reuse the same presentation trials as main blocks
  const presentTrial = (
    conditionLabel === 'FULL'   ? full_present :
    conditionLabel === 'RSVP'   ? rsvp_present :
    conditionLabel === 'UNCUED' ? uncued_present :
    cued_present
  );

  // decision trial for practice (marked and slightly labeled)
  const decidePractice = {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
      <div class="wrap">
        <p style="font-size:20px;">（练习）这个场景里有没有 Waldo？</p>
        <p class="muted">按 <b>F</b> = 有，按 <b>J</b> = 无</p>
        <p class="muted">提示：作答时间有限，请尽快作答。</p>
      </div>
    `,
    choices: [PARAM.keyPresent, PARAM.keyAbsent],
    trial_duration: PARAM.respLimit,
    data: {
      phase: 'practice',
      practice: true,
      condition: conditionLabel,
      stim_id: () => TV('stim_id'),
      img_path: () => TV('img_path'),
      target_present: () => TV('target_present')
    },
    on_finish: function(data){
      const timedOut = (data.response == null);
      data.timed_out = timedOut ? 1 : 0;

      const ans =
        data.response === PARAM.keyPresent ? 1 :
        data.response === PARAM.keyAbsent  ? 0 : null;
      data.answer_present = ans;

      if(timedOut){
        data.correct = null;
      } else {
        data.correct = (ans === data.target_present) ? 1 : 0;
      }
    }
  };

  return {
    timeline: [ fixation, presentTrial, decidePractice, practice_feedback, iti_blank ],
    timeline_variables: tvs
  };
}

function blockIntro(conditionLabel){
  const desc = {
    FULL:   '整图呈现',
    RSVP:   '中心 RSVP：16 段切块在中心快速串流',
    UNCUED: '蛇形位置呈现：16 段依次出现在各网格位置',
    CUED:   '蛇形位置呈现 + 下一位置提示'
  };
  return {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
      <div class="wrap">
        <h3>Block：${conditionLabel}</h3>
        <p>${desc[conditionLabel]}</p>
        <p class="muted">本 block 共 24 个试次。按空格开始。</p>
      </div>
    `,
    choices: [' '],
    record_data: false
  };
}

function makeBlock(conditionLabel){
  // 每个 block 都重新 shuffle 一份顺序（但内容仍是 12P+12A）
  const tvs = jsPsych.randomization.shuffle(base_trials);

  if(conditionLabel === 'FULL'){
    return {
      timeline: [ fixation, full_present, decide_FULL, iti_blank ],
      timeline_variables: tvs,
    };
  }
  if(conditionLabel === 'RSVP'){
    return {
      timeline: [ fixation, rsvp_present, decide_RSVP, iti_blank ],
      timeline_variables: tvs,
    };
  }
  if(conditionLabel === 'UNCUED'){
    return {
      timeline: [ fixation, uncued_present, decide_UNCUED, iti_blank ],
      timeline_variables: tvs,
    };
  }
  // default: CUED
  return {
    timeline: [ fixation, cued_present, decide_CUED, iti_blank ],
    timeline_variables: tvs,
  };
}

function buildSequenceForOrder(order){
  const seq = [];
  for(const cond of order){
    seq.push(practiceIntro(cond));
    seq.push(makePracticeBlock(cond));
    seq.push(blockIntro(cond));
    seq.push(makeBlock(cond));
  }
  return seq;
}

// Prebuild four possible sequences (Latin-square / counterbalanced order)
const SEQ_A = buildSequenceForOrder(ORDER_BY_GROUP.A);
const SEQ_B = buildSequenceForOrder(ORDER_BY_GROUP.B);
const SEQ_C = buildSequenceForOrder(ORDER_BY_GROUP.C);
const SEQ_D = buildSequenceForOrder(ORDER_BY_GROUP.D);

// Resolve group once, store for conditional nodes
let GROUP_RESOLVED = 'A';
let COND_ORDER_STR = ORDER_BY_GROUP.A.join('-');
const resolveGroupAndOrder = {
  type: jsPsychCallFunction,
  func: function(){
    const g = (jsPsych.data.get().values()[0]?.group || jsPsych.data.get().last(1).values()[0]?.group || 'A');
    GROUP_RESOLVED = (g || 'A').toString().trim().toUpperCase();
    if(!ORDER_BY_GROUP[GROUP_RESOLVED]) GROUP_RESOLVED = 'A';
    COND_ORDER_STR = ORDER_BY_GROUP[GROUP_RESOLVED].join('-');

    jsPsych.data.addProperties({
      group_resolved: GROUP_RESOLVED,
      cond_order: COND_ORDER_STR
    });
  }
};

function ifGroup(letter){
  return function(){
    return GROUP_RESOLVED === letter;
  };
}

const end_screen = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: `
    <div class="wrap">
      <h3>Step 2-C 完成</h3>
      <p class="muted">你已经完成了全部实验！</p>
      <p class="muted">数据会自动导出为 CSV，请下载后发给主试！</p>
      <p>按任意键结束。</p>
    </div>
  `
};

// timeline
const timeline = [
  demographics,
  preload,
  instructions_page1,
  instructions_page2,

  // resolve group/order once (jsPsych v8 safe)
  resolveGroupAndOrder,

  { timeline: SEQ_A, conditional_function: ifGroup('A') },
  { timeline: SEQ_B, conditional_function: ifGroup('B') },
  { timeline: SEQ_C, conditional_function: ifGroup('C') },
  { timeline: SEQ_D, conditional_function: ifGroup('D') },

  end_screen
];

jsPsych.run(timeline);

</script>
</html>

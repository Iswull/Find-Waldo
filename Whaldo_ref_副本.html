<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Let‘s Waldo</title>

  <script src="https://unpkg.com/jspsych@latest"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@latest"></script>
  <script src="https://unpkg.com/@jspsych/plugin-preload@latest"></script>
  <script src="https://unpkg.com/@jspsych/plugin-call-function@latest"></script>
  <script src="https://unpkg.com/@jspsych/plugin-survey-html-form@latest"></script>
  <link href="https://unpkg.com/jspsych@latest/css/jspsych.css" rel="stylesheet" />

  <style>
    body { background:#111; color:#eee; margin:0; }
    .wrap { max-width: 900px; margin: 48px auto; padding: 0 18px; line-height: 1.75; }
    .muted { opacity: 0.82; font-size: 14px; }
    .key { display:inline-block; padding:2px 8px; border:1px solid rgba(255,255,255,0.25); border-radius:8px; }
    code { background: rgba(255,255,255,0.10); padding: 2px 6px; border-radius: 6px; }
  </style>
</head>

<body></body>

<script>

if (window.location.protocol === 'file:') {
  document.body.innerHTML = `
    <div class="wrap">
      <h2 style="color:#ff6b6b;">你现在是用 file:// 打开的</h2>
      <p>这会导致浏览器禁止把本地图片画到 canvas。</p>
      <p><b>请用本地服务器打开:</b></p>
      <p class="muted">终端运行：</p>
      <pre style="background:rgba(255,255,255,0.08);padding:12px;border-radius:10px;overflow:auto;">cd "/Users/aoeo/Desktop/读书读书我要读书/大三上/认知与行为实验技术/Waldo"
python3 -m http.server 8000</pre>
      <p class="muted">然后浏览器打开：</p>
      <p><code>http://localhost:8000/Whaldo_ref.html</code></p>
    </div>
  `;
  throw new Error('Opened via file://; please use http://localhost...');
}

const BASE = "https://cdn.jsdelivr.net/gh/Iswull/Find-Waldo@83a2f2c/";

const STIM = [
  { id: 1,  present: BASE + "Waldo_1_present.png",  absent: BASE + "Waldo_1_absent.png" },
  { id: 2,  present: BASE + "Waldo_2_present.png",  absent: BASE + "Waldo_2_absent.png" },
  { id: 3,  present: BASE + "Waldo_3_present.png",  absent: BASE + "Waldo_3_absent.png" },
  { id: 4,  present: BASE + "Waldo_4_present.png",  absent: BASE + "Waldo_4_absent.png" },
  { id: 5,  present: BASE + "Waldo_5_present.png",  absent: BASE + "Waldo_5_absent.png" },
  { id: 6,  present: BASE + "Waldo_6_present.png",  absent: BASE + "Waldo_6_absent.png" },
  { id: 7,  present: BASE + "Waldo_7_present.png",  absent: BASE + "Waldo_7_absent.png" },
  { id: 8,  present: BASE + "Waldo_8_present.png",  absent: BASE + "Waldo_8_absent.png" },
  { id: 9,  present: BASE + "Waldo_9_present.png",  absent: BASE + "Waldo_9_absent.png" },
  { id: 10, present: BASE + "Waldo_10_present.png", absent: BASE + "Waldo_10_absent.png" },
  { id: 11, present: BASE + "Waldo_11_present.png", absent: BASE + "Waldo_11_absent.png" },
  { id: 12, present: BASE + "Waldo_12_present.png", absent: BASE + "Waldo_12_absent.png" }
];

const CONDITIONS = ["FULL", "RSVP", "UNCUED", "CUED"];


const PARAM = {
  preFix: 300,  // trial 开头中心注视点（ms）
  seg: 150,    // RSVP/UNCUED/CUED 条件切块呈现时长
  mask: 150,
  cue: 250,      // 只有 CUED 用
  fullDur: 2400, // FULL 条件整图呈现时长

  // 反应限制
  respLimit: 2500,
  keyPresent: "f",
  keyAbsent: "j",

  // 试次间隔
  iti: 500,

  // 切块网格
  rows: 4,
  cols: 4,
  segSizePx: 260, // (legacy) 会在运行时同步为 cellSize，使 stage 为 1:1 且均匀 4×4

  // 简化：每个条件 12P+12A（=24 trials/cond）
  nPresentPerCond: 12,
  nAbsentPerCond: 12
};

// 初始化 jsPsych
const jsPsych = initJsPsych({
on_finish: function(){
    jsPsych.data.get().localSave('csv', 'waldo_exp5_4cond_step1.csv');
}
});

// 基本信息采集
const demographics = {
  type: jsPsychSurveyHtmlForm,
  html: `
    <div class="wrap">
      <h2>基本信息</h2>

      <p>
        <label>年龄（岁）：
          <input name="age" type="number" min="10" max="99" required style="width:120px; margin-left:8px;" />
        </label>
      </p>

      <p>
        <label>性别：
          <select name="gender" required style="width:160px; margin-left:8px;">
            <option value="" selected disabled>请选择</option>
            <option value="female">女</option>
            <option value="male">男</option>
            <option value="other">其他/不便透露</option>
          </select>
        </label>
      </p>

      <p class="muted">填写完成后点击“继续”。</p>
    </div>
  `,
  button_label: "继续",
  on_finish: function(data){
    const r = data.response || {};
    const ageNum = r.age === "" || r.age == null ? null : Number(r.age);
    jsPsych.data.addProperties({
      age: Number.isFinite(ageNum) ? ageNum : null,
      gender: r.gender || null,
    });
  }
};

// 全局字段：任务名 + 一个随机被试ID（之后可以改成让被试输入学号）
jsPsych.data.addProperties({
  task: "waldo_exp5_4cond_replication",
  subject_id: "S" + String(Math.floor(Math.random()*1e9))

});

// 预加载所有图片
const preload = {
  type: jsPsychPreload,
  images: STIM.flatMap(s => [s.present, s.absent]),
  message: `
    <div class="wrap">
      <p>正在加载实验图片…</p>
      <p class="muted">若失败：检查 <code>Waldo_try/</code> 是否与本 html 同级，以及文件名是否完全一致。</p>
      <p class="muted">并确保你是用 <code>http://localhost...</code> 打开，而不是 file://。</p>
    </div>
  `
};

const instructions = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: `
  <div class="wrap">
    <h2>Waldo 视觉搜索任务</h2>
    <p>欢迎参加实验。你将看到一系列“场景图片”（或被切分后的图片片段）。你的任务始终相同：</p>
    <p>判断该场景中是否出现 Waldo。</p>

    <h3 style="margin-top:18px;">作答方式</h3>
    <p>请尽量又快又准地作答：</p>
    <p><span class="key">F</span> = 有 Waldo　　<span class="key">J</span> = 没有 Waldo</p>

    <h3 style="margin-top:18px;">实验结构</h3>
    <p>实验包含1个练习模块与4个正式模块:</p>
    <p>每个模块的呈现方式不同，但你的判断任务不变。</p>

    <h3 style="margin-top:18px;">实验过程中请专注屏幕</h3>

    <h3 style="margin-top:18px;">准备好后按 <b>空格键</b> 开始练习</h3>
  </div>
`,
  choices: [" "],
  record_data: false
};

let CURRENT_TRIAL = { stim_id: null, img_path: null, target_present: null };

// 兼容不同 jsPsych 版本：正确“取出” timeline_variables 里的真实值
function TV(name){
  // jsPsych v8: evaluateTimelineVariable
  if (typeof jsPsych.evaluateTimelineVariable === 'function') {
    return jsPsych.evaluateTimelineVariable(name);
  }
  // jsPsych v7: timelineVariable(name, evaluateFunctions)
  if (typeof jsPsych.timelineVariable === 'function') {
    try {
      return jsPsych.timelineVariable(name, true);
    } catch (e) {
      return jsPsych.timelineVariable(name);
    }
  }
  return undefined;
}

// cued fixation 
const fixation = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: `<div style="font-size:48px;">+</div>`,
  choices: "NO_KEYS",
  trial_duration: PARAM.preFix,
  record_data: false,

  on_start: function(){
    CURRENT_TRIAL.stim_id = TV('stim_id');
    CURRENT_TRIAL.img_path = TV('img_path');
    CURRENT_TRIAL.target_present = TV('target_present');
  }
};

// 把每个 trial 变成：
// fixation(300ms) -> cued_present(16段) -> decide(F/J)
// CUED 的 16 段时序（每段）：
// 1) 切块呈现 seg=150ms
// 2) 彩色 mask mask=150ms
// 3) 下一位置注视点 cue=250ms（最后一段后不呈现）

// 1.生成 4×4 的“蛇形路径”位置（用网格坐标 r/c，而不是屏幕百分比）
function makeSnakePositions(){
  const pos = [];
  for(let r=0; r<PARAM.rows; r++){
    if(r % 2 === 0){
      for(let c=0; c<PARAM.cols; c++) pos.push({ r, c });
    } else {
      for(let c=PARAM.cols-1; c>=0; c--) pos.push({ r, c });
    }
  }
  return pos; // 共 rows*cols 个位置
}
const SNAKE_POS = makeSnakePositions();

// 2.等待（ms）
function waitMs(ms){ return new Promise(res => setTimeout(res, ms)); }

// 计算“正方形 stage”与每个网格 cell 的几何信息
let STAGE_INFO = null;
function computeStageInfo(){
  const vw = window.innerWidth;
  const vh = window.innerHeight;
  const side = Math.min(vw, vh);

  // 让每格为整数像素，避免缝隙
  const cell = Math.floor(side / PARAM.cols);
  const size = cell * PARAM.cols;

  const left = Math.floor((vw - size) / 2);
  const top  = Math.floor((vh - size) / 2);

  return { left, top, size, cell };
}

// 3.在 jsPsych 显示区域里创建一个 stage
function ensureStage(){
  const display = jsPsych.getDisplayElement() || document.body;
  let s = display.querySelector('#stage');
  if(!s){
    s = document.createElement('div');
    s.id = 'stage';
    display.appendChild(s);
  }

  // 每次进入呈现阶段都重新计算（支持不同屏幕/全屏变化）
  STAGE_INFO = computeStageInfo();

  s.style.position = 'absolute';
  s.style.left = STAGE_INFO.left + 'px';
  s.style.top  = STAGE_INFO.top  + 'px';
  s.style.width  = STAGE_INFO.size + 'px';
  s.style.height = STAGE_INFO.size + 'px';
  s.style.overflow = 'hidden';
  s.style.background = 'transparent';

  // 调试时可打开边框
  // s.style.border = '1px solid rgba(255,255,255,0.25)';

  s.innerHTML = '';
  return s;
}

// 4.加载图片（把相对路径解析成 http://localhost... 的绝对 URL）
function resolveUrl(path){
  return new URL(path, window.location.href).href;
}
// ✅ 防呆：有时 img_path 会被误传成对象（导致 URL 变成 [object Object]）
function normalizeImgPath(maybePath, targetPresent){
  if(typeof maybePath === 'string') return maybePath;
  if(maybePath && typeof maybePath === 'object'){
    // 常见误传：把 STIM 对象直接塞进 img_path
    if('present' in maybePath || 'absent' in maybePath){
      return targetPresent ? maybePath.present : maybePath.absent;
    }
    // 其它可能的包装
    if('path' in maybePath) return maybePath.path;
    if('url' in maybePath) return maybePath.url;
  }
  return String(maybePath);
}
function loadImage(path){
  const url = resolveUrl(path);
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = async () => {
      try { if(img.decode) await img.decode(); } catch(e) {}
      resolve(img);
    };
    img.onerror = () => reject(new Error('图片加载失败(URL): ' + url));
    img.crossOrigin = 'anonymous';
    img.src = url;
  });
}

// 5.计算第 segIndex 块在“原图”上应该裁切的区域
function getCropRect(imgW, imgH, segIndex){
  const r = Math.floor(segIndex / PARAM.cols);
  const c = segIndex % PARAM.cols;
  const sw = imgW / PARAM.cols;
  const sh = imgH / PARAM.rows;
  return { sx: c*sw, sy: r*sh, sw, sh };
}

// 6.在某个位置画出“切块”
function drawSegmentAt(stage, imgEl, segIndex, pos){
  const info = STAGE_INFO || computeStageInfo();
  const size = info.cell; // ✅ 每格就是切块大小

  const cnv = document.createElement('canvas');
  cnv.width = size;
  cnv.height = size;
  cnv.style.position = 'absolute';
  cnv.style.left = (pos.c * size) + 'px';
  cnv.style.top  = (pos.r * size) + 'px';
  stage.appendChild(cnv);

  const ctx = cnv.getContext('2d');
  const rect = getCropRect(imgEl.naturalWidth, imgEl.naturalHeight, segIndex);
  ctx.drawImage(imgEl, rect.sx, rect.sy, rect.sw, rect.sh, 0, 0, cnv.width, cnv.height);
}

// 6.1 在 stage 中心呈现一个切块（给 RSVP 用：所有切块都在中心快速串流）
function drawSegmentCenter(stage, imgEl, segIndex){
  const info = STAGE_INFO || computeStageInfo();
  const size = info.cell;

  const cnv = document.createElement('canvas');
  cnv.width = size;
  cnv.height = size;
  cnv.style.position = 'absolute';
  cnv.style.left = (info.size/2 - size/2) + 'px';
  cnv.style.top  = (info.size/2 - size/2) + 'px';
  stage.appendChild(cnv);

  const ctx = cnv.getContext('2d');
  const rect = getCropRect(imgEl.naturalWidth, imgEl.naturalHeight, segIndex);
  ctx.drawImage(imgEl, rect.sx, rect.sy, rect.sw, rect.sh, 0, 0, cnv.width, cnv.height);
}

// 6.2 在 stage 中心呈现 mask（给 RSVP 用）
function drawMaskCenter(stage){
  const info = STAGE_INFO || computeStageInfo();
  const size = info.cell;

  const cnv = document.createElement('canvas');
  cnv.width = size;
  cnv.height = size;
  cnv.style.position = 'absolute';
  cnv.style.left = (info.size/2 - size/2) + 'px';
  cnv.style.top  = (info.size/2 - size/2) + 'px';
  stage.appendChild(cnv);

  const ctx = cnv.getContext('2d');
  const block = Math.max(10, Math.round(size / 13));
  for(let y=0; y<size; y+=block){
    for(let x=0; x<size; x+=block){
      ctx.fillStyle = `hsl(${Math.random()*360}, 85%, 55%)`;
      ctx.fillRect(x, y, block, block);
    }
  }
}

// 7.在某个网格位置画 mask（彩色马赛克）
function drawMaskAt(stage, pos){
  const info = STAGE_INFO || computeStageInfo();
  const size = info.cell;

  const cnv = document.createElement('canvas');
  cnv.width = size;
  cnv.height = size;
  cnv.style.position = 'absolute';
  cnv.style.left = (pos.c * size) + 'px';
  cnv.style.top  = (pos.r * size) + 'px';
  stage.appendChild(cnv);

  const ctx = cnv.getContext('2d');
  // 让 mask 的块数随 cellSize 缩放，保持“马赛克密度”大致一致
  const block = Math.max(10, Math.round(size / 13));
  for(let y=0; y<size; y+=block){
    for(let x=0; x<size; x+=block){
      ctx.fillStyle = `hsl(${Math.random()*360}, 85%, 55%)`;
      ctx.fillRect(x, y, block, block);
    }
  }
}

// 8.在某个网格位置画 cue '+'（下一个位置提示）
function drawCuePlus(stage, pos){
  const info = STAGE_INFO || computeStageInfo();
  const size = info.cell;

  const d = document.createElement('div');
  d.style.position = 'absolute';
  d.style.left = (pos.c * size + size/2) + 'px';
  d.style.top  = (pos.r * size + size/2) + 'px';
  d.style.transform = 'translate(-50%, -50%)';
  d.style.fontSize = Math.round(size * 0.18) + 'px';
  d.style.color = '#fff';
  d.textContent = '+';
  stage.appendChild(d);
}

// 6.3 呈现 FULL：整图放进 1:1 stage
async function presentFull(imgPath){
  const stage = ensureStage();
  if(STAGE_INFO) PARAM.segSizePx = STAGE_INFO.cell;

  const fixedPath = normalizeImgPath(imgPath, CURRENT_TRIAL.target_present);
  const img = await loadImage(fixedPath);

  stage.innerHTML = '';
  const el = document.createElement('img');
  el.src = resolveUrl(fixedPath);
  el.style.width = '100%';
  el.style.height = '100%';
  el.style.objectFit = 'cover'; 
  el.draggable = false;
  stage.appendChild(el);

  await waitMs(PARAM.fullDur);
  stage.innerHTML = '';
}

// 6.4 呈现 UNCUED：蛇形位置依次呈现 16 段
async function presentUncued16(imgPath){
  const stage = ensureStage();
  if(STAGE_INFO) PARAM.segSizePx = STAGE_INFO.cell;
  stage.innerHTML = '<div style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:18px;opacity:.85;">Loading…</div>';

  const fixedPath = normalizeImgPath(imgPath, CURRENT_TRIAL.target_present);
  const img = await loadImage(fixedPath);

  for(let i=0; i<16; i++){
    stage.innerHTML = '';
    drawSegmentAt(stage, img, i, SNAKE_POS[i]);
    await waitMs(PARAM.seg);
    stage.innerHTML = '';
  }
}

// 6.5 呈现 RSVP：16 段都在 stage 中心串流
async function presentRsvp16(imgPath){
  const stage = ensureStage();
  if(STAGE_INFO) PARAM.segSizePx = STAGE_INFO.cell;
  stage.innerHTML = '<div style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:18px;opacity:.85;">Loading…</div>';

  const fixedPath = normalizeImgPath(imgPath, CURRENT_TRIAL.target_present);
  const img = await loadImage(fixedPath);

  for(let i=0; i<16; i++){
    stage.innerHTML = '';
    drawSegmentCenter(stage, img, i);
    await waitMs(PARAM.seg);
    stage.innerHTML = '';
  }
}

// 9.执行一次 CUED 呈现（16 段循环）
async function presentCued16(imgPath){
  const stage = ensureStage();
  if(STAGE_INFO) PARAM.segSizePx = STAGE_INFO.cell;
  stage.innerHTML = '<div style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:18px;opacity:.85;">Loading…</div>';

  const fixedPath = normalizeImgPath(imgPath, CURRENT_TRIAL.target_present);
  const img = await loadImage(fixedPath);

  for(let i=0; i<16; i++){
    stage.innerHTML = '';
    drawSegmentAt(stage, img, i, SNAKE_POS[i]);
    await waitMs(PARAM.seg);

    stage.innerHTML = '';
    drawMaskAt(stage, SNAKE_POS[i]);
    await waitMs(PARAM.mask);

    stage.innerHTML = '';
    if(i < 15){
      drawCuePlus(stage, SNAKE_POS[i+1]);
      await waitMs(PARAM.cue);
    }
  }

  stage.innerHTML = '';
}

// 10.把“呈现阶段”做成一个 jsPsych trial
const cued_present = {
  type: jsPsychCallFunction,
  async: true,

  func: function(done){
    const run = async () => {
      const imgPath = CURRENT_TRIAL.img_path;
      if(!imgPath){
        throw new Error('imgPath is empty/undefined.');
      }
      await presentCued16(imgPath);
    };

    const p = run();

    // callback-style
    if (typeof done === 'function') {
      p.then(() => done()).catch((e) => { console.error(e); done(); });
    }

    // promise-style
    return p;
  },

  data: {
    stage: 'cued_present',
    seg_ms: PARAM.seg,
    mask_ms: PARAM.mask,
    cue_ms: PARAM.cue,
    rows: PARAM.rows,
    cols: PARAM.cols
  }
};

// 10.5 ITI（空屏）
const iti_blank = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: '',
  choices: 'NO_KEYS',
  trial_duration: PARAM.iti,
  record_data: false
};

// FULL 呈现 trial
const full_present = {
  type: jsPsychCallFunction,
  async: true,
  func: function(done){
    const run = async () => {
      const imgPath = CURRENT_TRIAL.img_path;
      if(!imgPath) throw new Error('imgPath is empty/undefined.');
      await presentFull(imgPath);
    };
    const p = run();
    if (typeof done === 'function') p.then(() => done()).catch((e)=>{console.error(e); done();});
    return p;
  },
  data: { stage: 'full_present', fullDur: PARAM.fullDur, rows: PARAM.rows, cols: PARAM.cols }
};

// RSVP 呈现 trial
const rsvp_present = {
  type: jsPsychCallFunction,
  async: true,
  func: function(done){
    const run = async () => {
      const imgPath = CURRENT_TRIAL.img_path;
      if(!imgPath) throw new Error('imgPath is empty/undefined.');
      await presentRsvp16(imgPath);
    };
    const p = run();
    if (typeof done === 'function') p.then(() => done()).catch((e)=>{console.error(e); done();});
    return p;
  },
  data: { stage: 'rsvp_present', seg_ms: PARAM.seg, mask_ms: PARAM.mask, rows: PARAM.rows, cols: PARAM.cols }
};

// UNCUED 呈现 trial
const uncued_present = {
  type: jsPsychCallFunction,
  async: true,
  func: function(done){
    const run = async () => {
      const imgPath = CURRENT_TRIAL.img_path;
      if(!imgPath) throw new Error('imgPath is empty/undefined.');
      await presentUncued16(imgPath);
    };
    const p = run();
    if (typeof done === 'function') p.then(() => done()).catch((e)=>{console.error(e); done();});
    return p;
  },
  data: { stage: 'uncued_present', seg_ms: PARAM.seg, mask_ms: PARAM.mask, rows: PARAM.rows, cols: PARAM.cols }
};

// cued decision
function makeDecideTrial(conditionLabel){
  return {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
      <div class="wrap">
        <p style="font-size:20px;">这个场景里有没有 Waldo？</p>
        <p class="muted">按 <b>F</b> = 有　　按 <b>J</b> = 无</p>
      </div>
    `,
    choices: [PARAM.keyPresent, PARAM.keyAbsent],
    trial_duration: PARAM.respLimit,
    data: {
      condition: conditionLabel,
      stim_id: () => TV('stim_id'),
      img_path: () => TV('img_path'),
      target_present: () => TV('target_present')
    },
    on_finish: function(data){
      const ans =
        data.response === PARAM.keyPresent ? 1 :
        data.response === PARAM.keyAbsent  ? 0 : null;
      data.answer_present = ans;
      data.correct = (ans === data.target_present) ? 1 : 0;
    }
  };
}

const decide_FULL   = makeDecideTrial('FULL');
const decide_RSVP   = makeDecideTrial('RSVP');
const decide_UNCUED = makeDecideTrial('UNCUED');
const decide_CUED   = makeDecideTrial('CUED');

//自动生成 12P + 12A（共 24 个）试次
//每个场景 id=1..12：present 用一次（target_present=1）；absent  用一次（target_present=0）
//把 24 条随机打乱。每个场景在 present/absent 中各出现一次（平衡）。
function buildTrials_12P12A(){
  const trials = [];
  // 12 条 present
  for(const s of STIM){
    trials.push({
      stim_id: s.id,
      img_path: s.present,
      target_present: 1
    });
  }
  // 12 条 absent
  for(const s of STIM){
    trials.push({
      stim_id: s.id,
      img_path: s.absent,
      target_present: 0
    });
  }
  // 随机打乱顺序
  return jsPsych.randomization.shuffle(trials);
}

const base_trials = buildTrials_12P12A();

function blockIntro(conditionLabel){
  const desc = {
    FULL:   '整图呈现（1:1 stage）',
    RSVP:   '中心 RSVP：16 段切块在中心快速串流',
    UNCUED: '蛇形位置呈现：16 段依次出现在各网格位置（无 cue）',
    CUED:   '蛇形位置呈现 + 下一位置 cue（+）'
  };
  return {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `
      <div class="wrap">
        <h3>Block：${conditionLabel}</h3>
        <p>${desc[conditionLabel]}</p>
        <p class="muted">本 block 共 24 个试次（12 有 + 12 无）。按空格开始。</p>
      </div>
    `,
    choices: [' '],
    record_data: false
  };
}

function makeBlock(conditionLabel){
  // 每个 block 都重新 shuffle 一份顺序（但内容仍是 12P+12A）
  const tvs = jsPsych.randomization.shuffle(base_trials);

  if(conditionLabel === 'FULL'){
    return {
      timeline: [ fixation, full_present, decide_FULL, iti_blank ],
      timeline_variables: tvs,
    };
  }
  if(conditionLabel === 'RSVP'){
    return {
      timeline: [ fixation, rsvp_present, decide_RSVP, iti_blank ],
      timeline_variables: tvs,
    };
  }
  if(conditionLabel === 'UNCUED'){
    return {
      timeline: [ fixation, uncued_present, decide_UNCUED, iti_blank ],
      timeline_variables: tvs,
    };
  }
  // default: CUED
  return {
    timeline: [ fixation, cued_present, decide_CUED, iti_blank ],
    timeline_variables: tvs,
  };
}

const block_FULL   = makeBlock('FULL');
const block_RSVP   = makeBlock('RSVP');
const block_UNCUED = makeBlock('UNCUED');
const block_CUED   = makeBlock('CUED');

const end_screen = {
  type: jsPsychHtmlKeyboardResponse,
  stimulus: `
    <div class="wrap">
      <h3>Step 2-C 完成</h3>
      <p class="muted">你已经完成：4 个条件 block（FULL / RSVP / UNCUED / CUED），每个 24 个试次（12 有 + 12 无）。</p>
      <p class="muted">数据会自动导出为 CSV：<code>waldo_exp5_4cond_step1.csv</code>。</p>
      <p>按任意键结束。</p>
    </div>
  `
};

  // timeline
const timeline = [
  preload,
  demographics,
  instructions,

  blockIntro('FULL'),
  block_FULL,

  blockIntro('RSVP'),
  block_RSVP,

  blockIntro('UNCUED'),
  block_UNCUED,

  blockIntro('CUED'),
  block_CUED,

  end_screen
];

jsPsych.run(timeline);

</script>
</html>
